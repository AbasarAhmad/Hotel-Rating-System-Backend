Before Microservices: 
*	Monolithic architecture: multiple components are combined in single large app. 
*	Single Code Base 
*	Deployment in single bundle 
*	Change in one service then whole app is redeployed 
*	Building problem: developers has to communicate
*	Problem in scale
*	Cumbersome over time
 
 

Microservices: 
‚Ä¢	Large apps are divide into small parts 
‚Ä¢	Different codebase 
‚Ä¢	Each module managed independently 
‚Ä¢	Different tech stack 
‚Ä¢	Handling microservices is complex 



Eureka
1. What is Eureka?
Eureka is a Service Discovery Server used so microservices can find each other automatically.

2. Why we use Eureka?
‚Ä¢	Services run on different ports
‚Ä¢	Ports change when restarting
‚Ä¢	Hardcoding URLs breaks the system
Eureka keeps a registry of all services and their locations.

3. How Eureka works?
Each microservice registers itself to Eureka:
Example Services & Ports
UserService   ‚Üí localhost:8081
HotelService  ‚Üí localhost:8082‚ùå Tum direct URL use karte ho ‚Üí Eureka use nahi hota
String url = "http://localhost:8083/api/ratings/get/userId/" + user.getUserId();


Ye direct IP + port call karta hai.
Isme Eureka bilkul involve nahi hota.

‚úîÔ∏è Eureka tab kaam karta hai jab tum SERVICE-NAME use karo

Example:

String url = "http://RATINGSERVICE/ratings/get/userId/" + user.getUserId();


Yaha RATINGSERVICE ‚Üí Eureka registry se milta hai.
Eureka find karta hai ki RATINGSERVICE ka instance kis port pe run ho raha hai.
RatingService ‚Üí localhost:8083
Eureka stores this information like a phone directory.

4. Real-Life Eureka = Hotel Reception
‚Ä¢	Microservices = Rooms
Guests don‚Äôt search rooms themselves ‚Äî
they ask reception: ‚ÄúRoom 8082 kaha hai?‚Äù
Similarly:
UserService ‚Üí asks Eureka ‚Üí ‚ÄúWhere is HotelService?‚Äù
Eureka ‚Üí returns actual URL (localhost:8082)
________________________________________



@LoadBalanced : RestTemplate ko smart bana deta hai taaki wo service-name ke through API call kare, port ya hostname ke through nahi.

‚ùå Ham direct URL use karte hai to  Eureka use nahi hota
String url = "http://localhost:8083/api/ratings/get/userId/" + user.getUserId();


Ye direct IP + port call karta hai.
Isme Eureka bilkul involve nahi hota.

‚úîÔ∏è Eureka tab kaam karta hai jab tum SERVICE-NAME use karo

Example:

String url = "http://RATINGSERVICE/ratings/get/userId/" + user.getUserId();


Yaha RATINGSERVICE ‚Üí Eureka registry se milta hai.
Eureka find karta hai ki RATINGSERVICE ka instance kis port pe run ho raha hai.




What is Feign Client 

Feign Client ek declarative HTTP client hai.

Matlab:

Tum API call ka code nahi likhte (RestTemplate wala).

Tum sirf interface bnate ho, aur Feign tumhare liye API call automatically kar deta hai.

Example:

@FeignClient(name="HOTELSERVICE")
public interface HotelService {

    @GetMapping("/api/hotels/get/{hotelId}")
    Hotel getHotel(@PathVariable String hotelId);
}
‡§¨‡§∏ itna code likh diya ‚Äî Feign khud:

‚úî Service discovery se URL find karega
‚úî HTTP request send karega
‚úî JSON ko Hotel object me convert karega
‚úî Errors handle karega

Yeh sab tumhe RestTemplate se manually karna padta tha.

üí• WHAT HAPPENS IF YOU DO NOT USE FEIGN?

Agar Feign nahi use karoge, to tumhari microservices me ye problems aayengi:

‚ùå 1. MORE CODE REQUIRED (Boilerplate)

Without Feign ‚Üí tumko har request ke liye RestTemplate likhna padega:

String url = "http://HOTELSERVICE/api/hotels/get/" + hotelId;
ResponseEntity<Hotel> response = restTemplate.getForEntity(url, Hotel.class);
Hotel hotel = response.getBody();

‚Üí Bohot length aur repetitive code hota hai.

‚ùå 2. MANUAL SERVICE DISCOVERY

@LoadBalanced RestTemplate use karna padega:

http://HOTELSERVICE/...

Aur tumko:

Load balancing handle karna

Error handling karna

Logging karna

‚Ä¶ye sab manually karna padta hai.

‚ùå 3. HARDER TO MAINTAIN

Agar endpoint change ho gaya:

RestTemplate URLs dhundh dhundh kar update karne padenge.

Feign me bas interface update = sab kaam auto ho jata hai.

‚ùå 4. NO AUTOMATIC FAILOVER / RETRIES

Feign + LoadBalancer + CircuitBreaker
‚Üí automatic retries, fallback, fault-tolerance deta hai.

RestTemplate me ye sb tumko manually likhna padta.



Before APIGATEWAY:
		http://localhost:8081/api/users/get
		http://localhost:8082/api/hotels/get
		http://localhost:8083/api/ratings/get

After  APIGATEWAY:
	we are able to fetch these urls:
		http://localhost:8084/api/users/get
		http://localhost:8084/api/ratings/get



When i am hitting this api :    http://localhost:8082/api/staffs   getting output
but when i am trying to hit this api gateway :   http://localhost:8084/api/staffs  getting error's 


so we did change in  apiGateway properties file :
 	# HOTEL SERVICE ROUTE
        - id: HOTELSERVICE
          uri: lb://HOTELSERVICE
          predicates:
            - Path=/api/hotels/**, /api/staffs/**

Now we are able to run  this url also :   http://localhost:8084/api/staffs
means ki koi new url agar add hota hai to hamai usko apiGateWay mai entry krainge tabhi GateWay ke through access kr painge.





======= Config Server: 

 	Spring Boot Config Server ek centralized configuration management solution hai jo Spring Cloud ka part hota hai. Iska main kaam hota hai 	multiple microservices ke configuration (properties / YAML) ko ek jagah se manage karna.

	Main simple words mein:
	üëâ Config Server ek alag Spring Boot application hoti hai jo config files ko Git (ya kisi aur source) se read karke client services ko 	runtime par provide karti hai.

Problem kya hoti hai bina Config Server ke?
	Agar tumhare paas 5‚Äì10 microservices hain:
	Har service ka application.yml
	Har environment ka alag config (dev / qa / prod)
	Change ke liye sab services ko redeploy karna padta hai

Config Server kya solve karta hai? :
	‚úî Central place par config
	‚úî Environment-wise config
	‚úî Runtime config refresh (without restart)
	‚úî Secure config (passwords, tokens)
	‚úî Easy scaling in microservices

Config Server ka Flow:
	Config files Git repo mein hoti hain
	Config Server Git se configs read karta hai
	Client service startup par Config Server se config fetch karti hai
	Properties local application.yml jaisi hi behave karti hain








=============  Fault Tolerance

Fault Tolerance ka matlab hota hai:
	üëâ Agar system ka koi part fail ho jaaye, tab bhi application gracefully kaam karti rahe aur pura system down na ho.

Microservices architecture mein yeh bahut critical concept hai, kyunki:
		Har service network par dependent hoti hai
		Network slow / down ho sakta hai
		Downstream service fail ho sakti hai

Problem bina Fault Tolerance ke: 

	UserService ‚Üí RatingService ‚Üí HotelService
	HotelService down ho gayi ‚ùå
	‚û°Ô∏è RatingService fail
	‚û°Ô∏è UserService fail
	‚û°Ô∏è Pura flow break üí•

Fault Tolerance kya solve karta hai : 
	‚úî System crash hone se bachata hai
	‚úî Partial failure ko handle karta hai
	‚úî Better user experience deta hai
	‚úî Cascading failure prevent karta hai

Common Fault Tolerance Patterns: 
	1. Circuit Breaker:
		Agar repeatedly failure ho raha hai to calls temporarily band kar do
			Jab service bar-bar fail ho
			Circuit OPEN ho jata hai
			Direct fallback response milta hai
		Spring Boot mein mostly use hota hai: Resilience4j
	
	2. Fallback üõü

		Failure ke case mein default / backup response
		Example:
		HotelService down ‚Üí "Hotel info not available right now"
		User ko error dikhane ke bajay meaningful response milta hai üëç
	3
	.
	.

Circuit Breaker:
	Circuit Breaker ek fault tolerance pattern hai jo kisi failing service ko bar-bar call karne se rokta hai.
	üëâ Jab koi downstream service (jaise RatingService / HotelService) repeatedly fail karti hai, Circuit Breaker:

	Requests temporarily block kar deta hai
	System ko overload hone se bachata hai
	Fallback response return karta hai

Circuit Breaker States:
	CLOSED ‚Üí Normal calls allowed
	OPEN ‚Üí Calls blocked, direct fallback
	HALF-OPEN ‚Üí Few test calls, agar success ho to CLOSED